#множество SET
a = {1, 1.2, 'hello'}
#CREATE
a = {} # Пустое множество
b = set() # Пустое множество
c = frozenset() # Пустое неизменяемое множество
a = {1, 1.1, 'a', (1,1.1), None, True, print} # Множество в котом : целое; вещественное; строкоыое; кортеж; пустой тип; булевый тип; встроенная функция
a = {1, 1.1, [1,2]} # Обмануть встроенные проверки  добавлением списка  в кортеж не получится , возникнет ошибка

a = frozenset({1,1.1}) # Так создается неизменяемое множество
a = [1, 'abc', 1] # Раньше я был списком
set(a) #{1, 'abc'}, но 'a' остался списком
b = set('слово') #{'с','л','о','в'}
c = frozenset('слово') # {'h','e','l','o'}
d = set([1,[2.1],1]) # Ошибка, внутри есть изменяемый тип
# RETRIVE
# ДОБАВЛЕНИЕ
a = {1, 1.1, 'a'}
a.add('привет!') # Теперь в "a" {1, 1.1, 'a', 'привет!'}
b = 1
a.add(b) # Так b = 1, то во множество она не добавитсяб так как там уже есть 1

a = {1, 2, 3}
a.update({5, 2}) # Добавляет значения (объекты), во множество из другого множества. Помним, что во множестве элементы уникальные. Теперь "a" {1, 2, 3, 5}
# ПОЛУЧЕНИЕ
a = {1, 1.1, 'a'} #
a[0] #

# UPDATE
a = {1, 1.1, 'a'}
a[0] = 'a' #
a = {1, 2, 3} #
# УДАЛЕНИЕ
a = {1, 1.1, 'a'}
del a[0] #
del a #

a = {1, 2, 3}
a.clear() #
a = {1, 2, 3, 4}
a.pop() #
a.remove(3) #
a.discard(5) #

a = {1, 2, 3}
b = {3, 5, 6}
c = a- b #
print(c) #
a -= b #